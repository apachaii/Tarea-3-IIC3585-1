//find_upper_bound_possibility inputs the length of the set, and output a set of that length meant
//to be used as upper bound with the highest number, and to find sets with lower ones.
    //create the set and the structures to store the sums and multiplications
    //for every element to be filled in the set
        //try fill that element with a number (starting with the lowest)
            //if the number is compatible the previous ones element
                //add it to the set
                //add the sums and multiplication to the structures
            //else continue the next higher number

// check_new_number_compatibility inputs the current products, the sums and multiplication
// made with the new number. Outputs if is valid add the new number to the searched ones
    // if there is an intersection between the new sums and the new multiplications or,
    // between each of those and the current products
        // return false
    // return true

// find_lower_bound inputs the length of the set and tries to approximate a lower bound, it can't be lower than
// the approximation
    // best found is n*2-1

// find_possible_set inputs a the end of a possible set, the product of that end,
// and the length to which expand the set. Create a set of that length with that end
// if is possible.
    // create the structures to store the new possibility and products
    // create the structures to store the products added en each element
    // the first number searched is the lower number in the end -1
    // while an structure wasn't found
        // if the number is lower than the lower bound and is the first searched
            // return is impossible order
        // if the number is lower than the lower bound
            // remove the previous one from the products
            // set searched number to the previous one -1
            // start searching from the previous one
        // if the number is compatible
            // add the number to the possible set
            // add the products
            // pass to the next number in the set
         // decrease the searched number
    // return the found set

// find_best_set inputs the length of the set and outputs the
// best set, the one with the lower highest number for that length
    // create the structures to contain the set and the products
    // for every element to be filled in the set (more to less order)
        // the starting number to search is the lower bound for the place
        // while the lower element haven't been found
            // try the current number
            // if it works
                // add the number to the set
                // add the sums and multiplications to the products
                // continue to the next number
            // else increase the number of the search
    // return the set