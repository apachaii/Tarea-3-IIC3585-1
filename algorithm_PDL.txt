
// check_new_number_compatibility inputs the current products, the sums and multiplication
// made with the new number. Outputs if is valid add the new number to the searched ones
    // if there is an intersection between the new sums and the new multiplications or,
    // between each of those and the current products
        // return false
    // return true

// find_lower_bound_difference inputs the position of the set and the already used differences.
// It calculates a lower bound.
// Assumes that de differences are sorted.
// It uses this:
// As the differences between 2 elements of the set can not be equal to any other difference, then
// a set of length n has to be at least the sum of 1,...,n.
// of the element in the position the set.
// of the element in the position the set.
    // create the structures to keep the sum of the differences
    // amount of used differences starts at the amount of space in-between
    // from the first difference until amount of used differences (or the length of the used differences)
        // if the difference is lower or equal than the amount of used differences
            // increase the amount of used differences by 1
            // add the current difference to the sum of differences
        // else break from the loop
    // the original lower bound if the amount of differences=n : n*(n+1)/2
    // the final lower bound is the original subtracted the sums of differences


// find_possible_set inputs a the end of a possible set which is assume is correct,
// the sums generated by of that end, the multiplications generated by of that end,
// the differences between each element of the set, and the length to which expand the set.
// It creates a set of that length with that end if is possible.
    // create the structures to store the new possibility
    // create the structures to store the sums, multiplications and differences added en each element
    // the first number searched is the lower number in the end - the lowest difference
    // while an structure wasn't found
        // if the number is lower than the lower bound and is the first searched
            // return is impossible order
        // if the number is lower than the lower bound
            // remove the previous one from the products
            // set searched number to the previous one -1
            // start searching from the previous one
        // if the number is 2 then it doesn't work
        // if the number is compatible
            // add the number to the possible set
            // add the sums, multiplications and differences
            // pass to the next number in the set
        // decrease the searched number by the lowest possible difference
    // return the found set

// find_best_set inputs the length of the set and outputs the
// best set, the one with the lower highest number for that length
    // create the structures to contain the set, the sums, and the differences
    // for every element to be filled in the set (more to less order)
        // the starting number to search is the lower bound for the place
        // while the lower element haven't been found
            // try the current number
            // if it works
                // add the number to the set
                // add the sums and multiplications to the products
                // continue to the next number
            // else increase the number of the search
    // return the set